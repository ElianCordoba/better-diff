# Tasks:
- Open close verifier
- Can node be matched alone
- Pass configs (compiler, lang name, openClose, singleMatchingNode) as language options

This is a high-level overview of the second version of the algorithm. I'm reworking the whole system to solve the following issues that arise during the development of the previous version and, despite the efforts, I couldn't build the existing architecture to solve them. So I'm starting from scratch with those limitations in mind, these are: 

# High prio

## Score based ranking of sequence s
The current heuristics are, in order:
- Sequence length (more is better)
- Number of segments (less is better)
- Number of skios (less is better)

We should also consider
- Text distance: for example
  1 Z 2
  1 ZZZ 2
  Both have 1 skips but the number of characters in between is different
- Position in text distnace: We could have multiple matches for a given sequece, some being closer by others being many lines of codes down bellow. We could prefer closer by matches
- Levenshtein distance

This score function could give a number from 1 - 100, higher number meaning more similarities, then we take this number to compare matches

Another application for a score function, perhaps not the same one, would be to try match as "Change", nodes that changed in the source code

```ts
  function asd() {
    return 123
  }

  // vs

  function ddd() {
    return 333
  }

  // This could be matched as a single move with the number literal as a change
```

For this usecase the score function could consider things like
- Text context (myers or Levenshtein)
- Kind

## Open-close verifier
TODO

## canNodeBeMatchedAlone config

## Check parent nodes to prevent semantic mistakes
Given:
```js
function asd() {
  return 1
}

// vs 

function asd() {
  return
  1
}
```

We should go X number of times up checking if `a.parent === b.parent`

TODO: Think if we want to enable this at all stages of the match finder or at the end only

## Changes compaction

Needed to enable the tests

## Move ignorer

This is a pre-requisite for the alignment problem. Should be enabled/disabled by option

This is important to enable tests

## Alignment
Haven't planned how to implement this but this has to be for version 1.0

Also we need to consider the case where `startLine !== endLine` form example tagged template literals

## Algo steps visualizer
We should create a `recordStep` function that tracks the current "Thinking" for the algorithm. This should be visualized in the front end (or terminal) by clicking forward / backwards. 
This is going to be pretty important to debug the algo, especially useful in tricky scenarios

############################# Low prio #############################

## Better organize code
We should have the possibility to override functions to experiment with new behaviours, for example how we diff code either with the string-to-string method or the zigzag algo

## Intra-node diffing
In the current approach, we consider the following a change

```ts
123123
'asdasd'

// ---
1233123
'asddasd'
```

While is true a better output would be to use Myers algo to diff the values

## Change type
I tinkered with this idea in the past, some experimentation is needed, the idea is that in some cases, instead of reporting an addition and deletion we can link both in a "change" for example:

```js
const value = 123

// vs 

const value = true
```

## Cross file diffs

## Brainstorm 3-way merge

## Highlighting
Maybe we have some business here

## Tree sitter & other languages
Also having languages communicate via RPC or something, right now we are loading typescript in a JS module, this will prevent us from using a non-js compiler
Maybe here we can also conside sublanguages, an HTML file can have JS and CSS as well as HTML code

## Plain text compiler
We could experimentate with being the differ of CRDT by writing a plain text parser that simply separest by white space, and structures the code per sentence / new line. 

## Another language supported

###################### DONE #############

## Moves now contain sections
Before we would create a move saying, "From X to Y it moved to A and B, limiting us to a single section, this is why we had to include the closing node as a separate field. Also, this single-section approach will limit us considering the above point where now a move could be, for example:
"perfect match", "addition", "perfect match"

So moves should have an array of sections